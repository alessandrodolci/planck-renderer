export class CanvasRenderer{constructor(t,e,n={}){const s={scale:16,lineWidth:1/16,strokeStyle:{dynamic:"black",static:"black",kinematic:"black"},textAlign:"start",font:"18px sans-serif"};this.options=Object.assign(s,n),n.lineWidth||(this.options.lineWidth=1/this.options.scale),this.canvasContent=t,this.ctx=e,this.canvas=e.canvas}clear(t,e){e.clearRect(0,0,t.width,t.height)}renderContent(){this.clear(this.canvas,this.ctx),this.renderText(),this.renderWorld()}renderText(){const t=this.canvasContent.textContentArray;this.ctx.save(),this.ctx.scale(this.options.scale,this.options.scale),this.ctx.textAlign=this.options.textAlign,this.ctx.font=this.options.font,t.forEach(t=>{this.ctx.fillText(t.text,t.x,t.y)}),this.ctx.restore()}renderWorld(){const{ctx:t,options:e}=this,n=this.canvasContent.world;for(let s=n.getBodyList();s;s=s.getNext())for(let n=s.getFixtureList();n;n=n.getNext()){if(s.render&&s.render.hidden)continue;s.render&&s.render.stroke?t.strokeStyle=s.render.stroke:s.isDynamic()?t.strokeStyle=e.strokeStyle.dynamic:s.isKinematic()?t.strokeStyle=e.strokeStyle.kinematic:s.isStatic()&&(t.strokeStyle=e.strokeStyle.static);const r=n.getType(),i=n.getShape();t.save(),t.scale(this.options.scale,this.options.scale),t.lineWidth=e.lineWidth,"circle"===r&&this.drawCircle(s,i),"edge"===r&&this.drawEdge(i),"polygon"===r&&this.drawPolygon(s,i),"chain"===r&&this.drawPolygon(s,i),t.restore()}for(let e=n.getJointList();e;e=e.getNext())t.save(),t.scale(this.options.scale,this.options.scale),this.drawJoint(e),t.restore()}drawCircle(t,e){const n=this.ctx,s=this.options.lineWidth,r=e.m_radius,i=t.getPosition(),o=t.getAngle(),a=2*r+2*s;if(n.translate(i.x+s,i.y+s),n.rotate(o),t.render&&t.render.custom){const e={x:-r-2*s,y:-r-2*s};if(!0!==t.render.custom(n,e,a+s))return}n.beginPath(),n.arc(0,0,r,0,2*Math.PI),n.stroke(),n.restore()}drawEdge(t){const e=this.ctx,n=t.m_vertex1,s=t.m_vertex2;e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.lineCap="round",e.stroke()}drawPolygon(t,e){const n=this.ctx,s=this.options.lineWidth,r=e.m_vertices;if(!r.length)return;let i=1/0,o=1/0,a=-1/0,c=-1/0;for(const t of r)i=Math.min(i,t.x),a=Math.max(a,t.x),o=Math.min(o,t.y),c=Math.max(c,t.y);const h=a-i,l=c-o,d=t.getPosition(),x=t.getAngle();if(n.translate(d.x+2*s,d.y+2*s),n.rotate(x),t.render&&t.render.custom){const e={width:h+s,height:l+s},r={x:i-s,y:o-s};if(!0!==t.render.custom(n,r,e))return}n.beginPath();for(let t=0;t<r.length;++t){const e=r[t],i=e.x-s,o=e.y-s;0===t?n.moveTo(i,o):n.lineTo(i,o)}r.length>2&&n.closePath(),n.stroke()}drawJoint(t){const e=this.ctx,n=t.getAnchorA(),s=t.getAnchorB();e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()}}class Runner{constructor(t,e={}){this.options=Object.assign({fps:60,speed:1},e),this.canvasContent=t,this.runId=null,this.render=null,this.update=null}start(t=null,e=null){if(this.runId)return;t&&(this.render=t),e&&(this.update=e);const n=1/this.options.fps,s=1/this.options.speed*n;let r,i,o=performance.now(),a=0;const c=()=>{for(r=performance.now(),a+=Math.min(1,(r-o)/1e3);a>s;)this.canvasContent.world.step(n),"function"==typeof e&&this.update(n),a-=s;i=(r-o)/1e3,this.fps=1/i,o=r,this.render(),this.runId=requestAnimationFrame(c)};this.runId=requestAnimationFrame(c)}stop(){this.runId&&(cancelAnimationFrame(this.runId),this.runId=null)}}export{Runner};class SVGRenderer{constructor(){throw new Error("Your browser does not support the canvas element")}}export{SVGRenderer};const canvas=()=>!!document.createElement("canvas").getContext("2d"),Renderer=canvas()?CanvasRenderer:SVGRenderer;export default Renderer;