export class TextContent{constructor(t,e,n){this.text=t,this.x=e,this.y=n}}export class CanvasContent{constructor(t,e){this.world=t,this.textContentArray=e}}export class CanvasRenderer{constructor(t,e,n={}){const s={scale:16,lineWidth:1/16,strokeStyle:{dynamic:"black",static:"black",kinematic:"black"}};this.options=Object.assign(s,n),n.lineWidth||(this.options.lineWidth=1/this.options.scale),this.canvasContent=t,this.ctx=e,this.canvas=e.canvas}clear(t,e){e.clearRect(0,0,t.width,t.height)}renderContent(){this.renderText(),this.renderWorld()}renderText(){const t=this.canvasContent.textContentArray;this.ctx.save(),this.ctx.scale(this.options.scale,this.options.scale),t.forEach(t=>{this.ctx.fillText(...t)}),this.ctx.restore()}renderWorld(){const{ctx:t,canvas:e,options:n}=this,s=this.canvasContent.world;this.clear(e,t);for(let e=s.getBodyList();e;e=e.getNext())for(let s=e.getFixtureList();s;s=s.getNext()){if(e.render&&e.render.hidden)continue;e.render&&e.render.stroke?t.strokeStyle=e.render.stroke:e.isDynamic()?t.strokeStyle=n.strokeStyle.dynamic:e.isKinematic()?t.strokeStyle=n.strokeStyle.kinematic:e.isStatic()&&(t.strokeStyle=n.strokeStyle.static);const r=s.getType(),o=s.getShape();t.save(),t.scale(this.options.scale,this.options.scale),t.lineWidth=n.lineWidth,"circle"===r&&this.drawCircle(e,o),"edge"===r&&this.drawEdge(o),"polygon"===r&&this.drawPolygon(e,o),"chain"===r&&this.drawPolygon(e,o),t.restore()}for(let e=this.world.getJointList();e;e=e.getNext())t.save(),t.scale(this.options.scale,this.options.scale),this.drawJoint(e),t.restore()}drawCircle(t,e){const n=this.ctx,s=this.options.lineWidth,r=e.m_radius,o=t.getPosition(),i=t.getAngle(),a=2*r+2*s;if(n.translate(o.x+s,o.y+s),n.rotate(i),t.render&&t.render.custom){const e={x:-r-2*s,y:-r-2*s};if(!0!==t.render.custom(n,e,a+s))return}n.beginPath(),n.arc(0,0,r,0,2*Math.PI),n.stroke(),n.restore()}drawEdge(t){const e=this.ctx,n=t.m_vertex1,s=t.m_vertex2;e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.lineCap="round",e.stroke()}drawPolygon(t,e){const n=this.ctx,s=this.options.lineWidth,r=e.m_vertices;if(!r.length)return;let o=1/0,i=1/0,a=-1/0,c=-1/0;for(const t of r)o=Math.min(o,t.x),a=Math.max(a,t.x),i=Math.min(i,t.y),c=Math.max(c,t.y);const h=a-o,l=c-i,d=t.getPosition(),x=t.getAngle();if(n.translate(d.x+2*s,d.y+2*s),n.rotate(x),t.render&&t.render.custom){const e={width:h+s,height:l+s},r={x:o-s,y:i-s};if(!0!==t.render.custom(n,r,e))return}n.beginPath();for(let t=0;t<r.length;++t){const e=r[t],o=e.x-s,i=e.y-s;0===t?n.moveTo(o,i):n.lineTo(o,i)}r.length>2&&n.closePath(),n.stroke()}drawJoint(t){const e=this.ctx,n=t.getAnchorA(),s=t.getAnchorB();e.beginPath(),e.moveTo(n.x,n.y),e.lineTo(s.x,s.y),e.stroke()}}export default{TextContent:TextContent,CanvasContent:CanvasContent,CanvasRenderer:CanvasRenderer};class Runner{constructor(t,e={}){this.options=Object.assign({fps:60,speed:1},e),this.world=t,this.runId=null,this.render=null,this.update=null}start(t=null,e=null){if(this.runId)return;t&&(this.render=t),e&&(this.update=e);const n=1/this.options.fps,s=1/this.options.speed*n;let r,o,i=performance.now(),a=0;const c=()=>{for(r=performance.now(),a+=Math.min(1,(r-i)/1e3);a>s;)this.world.step(n),"function"==typeof e&&this.update(n),a-=s;o=(r-i)/1e3,this.fps=1/o,i=r,this.render(),this.runId=requestAnimationFrame(c)};this.runId=requestAnimationFrame(c)}stop(){this.runId&&(cancelAnimationFrame(this.runId),this.runId=null)}}export{Runner};class SVGRenderer{constructor(){throw new Error("Your browser does not support the canvas element")}}export{SVGRenderer};const canvas=()=>!!document.createElement("canvas").getContext("2d"),Renderer=canvas()?CanvasRenderer:SVGRenderer;export default Renderer;