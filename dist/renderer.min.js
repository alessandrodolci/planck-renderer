export class TextContent{constructor(t,e,s){this.text=t,this.x=e,this.y=s}}export class CanvasContent{constructor(t,e){this.world=t,this.textContentArray=e}}export class CanvasRenderer{constructor(t,e,s={}){const n={scale:16,lineWidth:1/16,strokeStyle:{dynamic:"black",static:"black",kinematic:"black"}};this.options=Object.assign(n,s),s.lineWidth||(this.options.lineWidth=1/this.options.scale),this.canvasContent=t,this.ctx=e,this.canvas=e.canvas}clear(t,e){e.clearRect(0,0,t.width,t.height)}renderContent(){this.renderText(),this.renderWorld()}renderText(){const t=this.canvasContent.textContentArray;this.ctx.save(),this.ctx.scale(this.options.scale,this.options.scale),t.forEach(t=>{this.ctx.fillText(...t)}),this.ctx.restore()}renderWorld(){const{ctx:t,canvas:e,options:s}=this,n=this.canvasContent.world;this.clear(e,t);for(let e=n.getBodyList();e;e=e.getNext())for(let n=e.getFixtureList();n;n=n.getNext()){if(e.render&&e.render.hidden)continue;e.render&&e.render.stroke?t.strokeStyle=e.render.stroke:e.isDynamic()?t.strokeStyle=s.strokeStyle.dynamic:e.isKinematic()?t.strokeStyle=s.strokeStyle.kinematic:e.isStatic()&&(t.strokeStyle=s.strokeStyle.static);const r=n.getType(),o=n.getShape();t.save(),t.scale(this.options.scale,this.options.scale),t.lineWidth=s.lineWidth,"circle"===r&&this.drawCircle(e,o),"edge"===r&&this.drawEdge(o),"polygon"===r&&this.drawPolygon(e,o),"chain"===r&&this.drawPolygon(e,o),t.restore()}for(let e=this.world.getJointList();e;e=e.getNext())t.save(),t.scale(this.options.scale,this.options.scale),this.drawJoint(e),t.restore()}drawCircle(t,e){const s=this.ctx,n=this.options.lineWidth,r=e.m_radius,o=t.getPosition(),i=t.getAngle(),a=2*r+2*n;if(s.translate(o.x+n,o.y+n),s.rotate(i),t.render&&t.render.custom){const e={x:-r-2*n,y:-r-2*n};if(!0!==t.render.custom(s,e,a+n))return}s.beginPath(),s.arc(0,0,r,0,2*Math.PI),s.stroke(),s.restore()}drawEdge(t){const e=this.ctx,s=t.m_vertex1,n=t.m_vertex2;e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.lineCap="round",e.stroke()}drawPolygon(t,e){const s=this.ctx,n=this.options.lineWidth,r=e.m_vertices;if(!r.length)return;let o=1/0,i=1/0,a=-1/0,c=-1/0;for(const t of r)o=Math.min(o,t.x),a=Math.max(a,t.x),i=Math.min(i,t.y),c=Math.max(c,t.y);const h=a-o,l=c-i,d=t.getPosition(),x=t.getAngle();if(s.translate(d.x+2*n,d.y+2*n),s.rotate(x),t.render&&t.render.custom){const e={width:h+n,height:l+n},r={x:o-n,y:i-n};if(!0!==t.render.custom(s,r,e))return}s.beginPath();for(let t=0;t<r.length;++t){const e=r[t],o=e.x-n,i=e.y-n;0===t?s.moveTo(o,i):s.lineTo(o,i)}r.length>2&&s.closePath(),s.stroke()}drawJoint(t){const e=this.ctx,s=t.getAnchorA(),n=t.getAnchorB();e.beginPath(),e.moveTo(s.x,s.y),e.lineTo(n.x,n.y),e.stroke()}}class Runner{constructor(t,e={}){this.options=Object.assign({fps:60,speed:1},e),this.world=t,this.runId=null,this.render=null,this.update=null}start(t=null,e=null){if(this.runId)return;t&&(this.render=t),e&&(this.update=e);const s=1/this.options.fps,n=1/this.options.speed*s;let r,o,i=performance.now(),a=0;const c=()=>{for(r=performance.now(),a+=Math.min(1,(r-i)/1e3);a>n;)this.world.step(s),"function"==typeof e&&this.update(s),a-=n;o=(r-i)/1e3,this.fps=1/o,i=r,this.render(),this.runId=requestAnimationFrame(c)};this.runId=requestAnimationFrame(c)}stop(){this.runId&&(cancelAnimationFrame(this.runId),this.runId=null)}}export{Runner};class SVGRenderer{constructor(){throw new Error("Your browser does not support the canvas element")}}export{SVGRenderer};const canvas=()=>!!document.createElement("canvas").getContext("2d"),Renderer=canvas()?CanvasRenderer:SVGRenderer;export default Renderer;